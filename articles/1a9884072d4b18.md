---
title: "æœ€æ–°AWSæƒ…å ±ã‚’ã€Incoming Webhooksã€‘ã§slackã«é€šçŸ¥"
emoji: "ğŸ“š"
type: "tech"
topics:
  - "aws"
  - "lambda"
  - "amazontranslate"
  - "slack"
  - "slackbot"
published: true
published_at: "2025-08-31 12:00"
---
# ã¯ã˜ã‚ã«
å‰å›ã€**AWSå…¬å¼RSS**ã‹ã‚‰LINEã«é€šçŸ¥ã™ã‚‹å®Ÿè£…ã‚’ã—ã¾ã—ãŸãŒã€ä»Šå›ã¯**Incoming Webhooks**ã‚’ä½¿ç”¨ã—ã¦`slack`ã¸ã‚‚é€šçŸ¥ã‚’ã—ã¦ã„ã“ã†ã¨æ€ã„ã¾ã™ã€‚
pythonã‚³ãƒ¼ãƒ‰ã‚„AWSã®æ§‹æˆã»ã¼åŒã˜ã§ã™ã€‚

https://zenn.dev/t_oishi/articles/10007f6fa2397b

**Bot Token + chat.postMessage**ã‚’ä½¿ç”¨ã—ãŸè¨˜äº‹ã¯ã“ã¡ã‚‰ã€‚
https://zenn.dev/t_oishi/articles/b1d6e7c36797c9

# å®Ÿè£…æ–¹æ³•
### slackã®è¨­å®š
äº‹å‰ã«slackã«ãƒ­ã‚°ã‚¤ãƒ³ã§ãã‚‹ã‚ˆã†ã«ã—ã¦ãŠã„ã¦ãã ã•ã„ã€‚

ã¾ãšã€BOTã‚’é€šçŸ¥ã—ãŸã„ãƒãƒ£ãƒ³ãƒãƒ«ã‚’ä½œæˆã—ã¦ãŠãã¾ã™ã€‚
ä»Šå›ã¯`# aws-bot`ã¨ã„ã†ãƒãƒ£ãƒ³ãƒãƒ«ã‚’ä½œæˆã—ã¦ãŠãã¾ã—ãŸã€‚
![](/images/1a9884072d4b18/image-1.png)

ãã®å¾Œã€ä»¥ä¸‹ã®URLã§`ã‚¢ãƒ—ãƒª`ã‚’ä½œæˆã—ã¦ã„ãã¾ã™ã€‚
https://api.slack.com/apps

![](/images/1a9884072d4b18/image-2.png)
![](/images/1a9884072d4b18/image-3.png)
ã‚¢ãƒ—ãƒªã®åå‰ã¨ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã®åå‰ã‚’é¸æŠã—ã¾ã™ã€‚
![](/images/1a9884072d4b18/image-4.png)
![](/images/1a9884072d4b18/image-5.png)
![](/images/1a9884072d4b18/image-6.png)
ä»¥ä¸‹ã®è¨­å®šã§å…¨ç„¶ä½œæˆã—ãŸãƒãƒ£ãƒ³ãƒãƒ«ãŒå‡ºã¦ã“ãšã€ï¼‘æ™‚é–“ãã‚‰ã„èª¿ã¹ã¦ã„ã¾ã—ãŸã€‚
â†’Xã‚’è¦‹ã¦ã„ãŸã‚‰`slack`ã®ä¸å…·åˆãŒã‚ã£ãŸã‚ˆã†ã§ã—ãŸã€‚ãƒãƒ£ãƒ³ãƒãƒ«ãŒå‡ºã¦ã“ãªã„ã¨ãã¯slackå…¬å¼ã§ä¸å…·åˆæƒ…å ±ãŒå‡ºã¦ãªã„ã‹è¦‹ã¦ã¿ã‚‹ã®ã‚‚ã„ã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚
![](/images/1a9884072d4b18/image-7.png)
`Webhook URL`ã‚’æ§ãˆã¦ãŠãã¾ã—ã‚‡ã†ã€‚
![](/images/1a9884072d4b18/image-8.png)

### Lambda
ä»¥ä¸‹ã¯LINEé€šçŸ¥ã‚‚å«ã¾ã‚Œã¦ã„ã¾ã™ã€‚

ç’°å¢ƒå¤‰æ•°ã«å…ˆã»ã©ã®`Webhook URL`ã‚’è¨­å®šã—ã¦ä¸‹ã•ã„ã€‚

```py
import os
import asyncio
import aiohttp
import feedparser
from datetime import datetime, timezone
import requests
import boto3
from botocore.exceptions import BotoCoreError, ClientError

# ç’°å¢ƒå¤‰æ•°
LINE_API_URL = "https://api.line.me/v2/bot/message/push"
LINE_TOKEN = os.environ["LINE_TOKEN"]
LINE_USER_ID = os.environ["LINE_USER_ID"]
SLACK_WEBHOOK_URL = os.environ.get("SLACK_WEBHOOK_URL")

# Amazon Translateã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
translate = boto3.client("translate", region_name="ap-northeast-1")

# é€ã£ãŸæ—¥ã¥ã‘
today_str = datetime.now(timezone.utc).strftime("%Y-%m-%d")

# RSSãƒ•ã‚£ãƒ¼ãƒ‰ä¸€è¦§
RSS_FEEDS = {
    "What's New with AWS": {"url": "https://aws.amazon.com/jp/about-aws/whats-new/recent/feed/", "translate": False},
    "AWS Blog": {"url": "https://aws.amazon.com/blogs/aws/feed/", "translate": True},
    "AWS Architecture Blog": {"url": "https://aws.amazon.com/jp/blogs/architecture/feed/", "translate": True},
    "AWS Partner Network (APN) Blog": {"url": "https://aws.amazon.com/jp/blogs/apn/feed/", "translate": True},
    "AWS Big Data Blog": {"url": "https://aws.amazon.com/jp/blogs/big-data/feed/", "translate": True},
    "AWS Compute Blog": {"url": "https://aws.amazon.com/jp/blogs/compute/feed/", "translate": True},
    "AWS Database Blog": {"url": "https://aws.amazon.com/jp/blogs/database/feed/", "translate": True},
    "AWS Desktop and Application Streaming Blog": {"url": "https://aws.amazon.com/jp/blogs/desktop-and-application-streaming/feed/", "translate": True},
    "AWS Developer Blog": {"url": "https://aws.amazon.com/jp/blogs/developer/feed/", "translate": True},
    "AWS DevOps Blog": {"url": "https://aws.amazon.com/jp/blogs/devops/feed/", "translate": True},
    "AWS Cloud Enterprise Strategy Blog": {"url": "https://aws.amazon.com/jp/blogs/enterprise-strategy/feed/", "translate": True},
    "Amazon Game Tech Blog": {"url": "https://aws.amazon.com/jp/blogs/gametech/feed/", "translate": True},
    "The Internet of Things on AWS â€“ Official Blog": {"url": "https://aws.amazon.com/jp/blogs/iot/feed/", "translate": True},
    "AWS Machine Learning Blog": {"url": "https://aws.amazon.com/jp/blogs/machine-learning/feed/", "translate": True},
    "AWS Management Tools Blog": {"url": "https://aws.amazon.com/jp/blogs/mt/feed/", "translate": True},
    "AWS Media Blog": {"url": "https://aws.amazon.com/jp/blogs/media/feed/", "translate": True},
    "AWS Messaging & Targeting Blog": {"url": "https://aws.amazon.com/jp/blogs/messaging-and-targeting/feed/", "translate": True},
    "AWS Mobile Blog": {"url": "https://aws.amazon.com/jp/blogs/mobile/feed/", "translate": True},
    "Networking & Content Delivery": {"url": "https://aws.amazon.com/jp/blogs/networking-and-content-delivery/feed/", "translate": True},
    "AWS Open Source Blog": {"url": "https://aws.amazon.com/jp/blogs/opensource/feed/", "translate": True},
    "AWS Government, Education, & Nonprofits Blog": {"url": "https://aws.amazon.com/jp/blogs/publicsector/feed/", "translate": True},
    "AWS for SAP": {"url": "https://aws.amazon.com/jp/blogs/awsforsap/feed/", "translate": True},
    "AWS Security Blog": {"url": "https://aws.amazon.com/jp/blogs/security/feed/", "translate": True},
    "AWS Startups Blog": {"url": "https://aws.amazon.com/jp/blogs/startups/feed/", "translate": True},
    "AWS Japan Blog": {"url": "https://aws.amazon.com/jp/blogs/news/feed/", "translate": False},
    "AWS Marketplace": {"url": "https://aws.amazon.com/blogs/awsmarketplace/feed/", "translate": True},
    "AWS Fundamentals Blog": {"url": "https://aws.amazon.com/blogs/training-and-certification/feed/", "translate": True},
    "AWS IoT Blog": {"url": "https://aws.amazon.com/blogs/iot/feed/", "translate": True},
    "é€±åˆŠAWS": {"url": "https://aws.amazon.com/jp/blogs/news/tag/%E9%80%B1%E5%88%8Aaws/feed/", "translate": False},
}

import re

def translate_title_if_needed(title, should_translate):
    """
    ãƒ•ã‚£ãƒ¼ãƒ‰è¨­å®šã«åŸºã¥ã„ã¦ã‚¿ã‚¤ãƒˆãƒ«ã‚’ç¿»è¨³ã™ã‚‹
    """
    if not should_translate:
        print(f"ç¿»è¨³è¨­å®šOFFã€ã‚¹ã‚­ãƒƒãƒ—: {title}")
        return title
        
    try:
        print(f"ç¿»è¨³è¨­å®šONã€ç¿»è¨³å®Ÿè¡Œ: {title}")
        result = translate.translate_text(
            Text=title,
            SourceLanguageCode="en",
            TargetLanguageCode="ja"
        )
        translated_title = result.get("TranslatedText", title)
        print(f"ç¿»è¨³å®Œäº†: {title} -> {translated_title}")
        return translated_title
        
    except (BotoCoreError, ClientError) as e:
        print(f"Translate error: {e}")
        return title

async def fetch_feed(session, name, feed_config):
    url = feed_config["url"]
    should_translate = feed_config["translate"]
    
    async with session.get(url) as resp:
        text = await resp.text()
        feed = feedparser.parse(text)
        today = datetime.now(timezone.utc).date()
        entries = []

        for entry in feed.entries[:10]:
            pub_date = None
            if hasattr(entry, "published_parsed") and entry.published_parsed:
                pub_date = datetime(*entry.published_parsed[:6], tzinfo=timezone.utc).date()
            elif hasattr(entry, "updated_parsed") and entry.updated_parsed:
                pub_date = datetime(*entry.updated_parsed[:6], tzinfo=timezone.utc).date()
            
            if pub_date == today:
                # ãƒ•ã‚£ãƒ¼ãƒ‰è¨­å®šã«åŸºã¥ã„ã¦ç¿»è¨³
                title = translate_title_if_needed(entry.title, should_translate)
                entries.append(f"ãƒ»{title}\n{entry.link}")
        return name, entries

async def fetch_all_feeds():
    async with aiohttp.ClientSession() as session:
        tasks = [fetch_feed(session, name, config) for name, config in RSS_FEEDS.items()]
        return await asyncio.gather(*tasks)

def send_line_message(message):
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {LINE_TOKEN}"
    }
    data = {
        "to": LINE_USER_ID,
        "messages": [{"type": "text", "text": message}]
    }
    resp = requests.post(LINE_API_URL, headers=headers, json=data)
    resp.raise_for_status()
    print("LINEé€ä¿¡æˆåŠŸ:", resp.status_code)

def send_slack_message(message):
    if not SLACK_WEBHOOK_URL:
        print("Slack Webhook URL ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€é€ä¿¡ã‚¹ã‚­ãƒƒãƒ—")
        return
    headers = {"Content-Type": "application/json"}
    data = {"text": message}
    resp = requests.post(SLACK_WEBHOOK_URL, headers=headers, json=data)
    resp.raise_for_status()
    print("Slacké€ä¿¡æˆåŠŸ:", resp.status_code)

def lambda_handler(event, context):
    feeds = asyncio.run(fetch_all_feeds())

    for name, entries in feeds:
        if entries:
            text = f"ã€{name}ã€‘ ({today_str})\n" + "\n".join(entries)
            send_line_message(text)
            send_slack_message(text)

    return {"statusCode": 200, "body": "é€šçŸ¥å®Œäº†"}

```

LINEã«é€šçŸ¥ã—ãŸããªã„å ´åˆã€ä¸‹è¨˜ã‚’å‰Šé™¤ã—ã¦ãã ã•ã„ã€‚
```py
def send_line_message(message):
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {LINE_TOKEN}"
    }
    data = {
        "to": LINE_USER_ID,
        "messages": [{"type": "text", "text": message}]
    }
    resp = requests.post(LINE_API_URL, headers=headers, json=data)
    resp.raise_for_status()
    print("LINEé€ä¿¡æˆåŠŸ:", resp.status_code)
```

ã“ã‚Œã§å®Œäº†ã§ã™ï¼

ç„¡æ–™ãƒ—ãƒ©ãƒ³ã¯ ç›´è¿‘90æ—¥åˆ†ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã—ã‹é–²è¦§ã§ããªã„ã®ã§ã€90æ—¥ã‚’è¶…ãˆã‚‹ã¨æ¤œç´¢ãƒ»è¡¨ç¤ºã§ããªããªã‚Šã¾ã™ã€‚