---
title: "æœ€æ–°AWSæƒ…å ±ã‚’ã€Bot Token + chat.postMessageã€‘ã§slackã«é€šçŸ¥"
emoji: "ğŸ˜¸"
type: "tech"
topics:
  - "aws"
  - "lambda"
  - "amazontranslate"
  - "slack"
  - "slackbot"
published: true
published_at: "2025-08-31 13:00"
---
# ã¯ã˜ã‚ã«
å‰å›ã®`slack`é€šçŸ¥BOTã¯ã€`Incoming Webhooks`ã‚’ä½¿ç”¨ã—ã¾ã—ãŸãŒã€ä»Šå›ã¯`Bot Token + chat.postMessage`ã§å®Ÿè£…ã—ã¦ã„ããŸã„ã¨æ€ã„ã¾ã™ã€‚


# Incoming Webhooksã¨Bot Token + chat.postMessageã®é•ã„
### Incoming Webhooks
**ä»•çµ„ã¿**
slack ãŒç™ºè¡Œã™ã‚‹ URL (Webhook URL) ã«å¯¾ã—ã¦ JSON ã‚’ POST ã™ã‚‹ã¨ã€æŒ‡å®šã•ã‚ŒãŸãƒãƒ£ãƒ³ãƒãƒ«ã«æŠ•ç¨¿ã•ã‚Œã‚‹ã€‚

**ãƒ¡ãƒªãƒƒãƒˆ**
- è¨­å®šãŒã‚·ãƒ³ãƒ—ãƒ«ï¼ˆWebhook URL ã«æŠ•ã’ã‚‹ã ã‘ï¼‰
- çŸ­æœŸçš„ãƒ»å°è¦æ¨¡ãªé€šçŸ¥ç”¨é€”ãªã‚‰ã™ãä½¿ãˆã‚‹

**ãƒ‡ãƒ¡ãƒªãƒƒãƒˆ**
- æŠ•ç¨¿å…ˆãƒãƒ£ãƒ³ãƒãƒ«ã¯å›ºå®šã•ã‚ŒãŒã¡ï¼ˆåŸºæœ¬ã¯ç™ºè¡Œæ™‚ã«æŒ‡å®šï¼‰
- æ¨©é™ç®¡ç†ãŒæŸ”è»Ÿã§ãªã„ï¼ˆWebHook URL ãŒæ¼ã‚Œã‚‹ã¨èª°ã§ã‚‚æŠ•ç¨¿ã§ãã‚‹ï¼‰
- slack å…¬å¼çš„ã«ã¯ãƒ¬ã‚¬ã‚·ãƒ¼æ‰±ã„ï¼ˆä»Šå¾Œã¯ Bot Token æ¨å¥¨ï¼‰

### Bot Token + chat.postMessage API
**ä»•çµ„ã¿**
æŠ•ç¨¿å…ˆãƒãƒ£ãƒ³ãƒãƒ«ã¯ API å‘¼ã³å‡ºã—æ™‚ã«æŒ‡å®šã§ãã‚‹

https://docs.slack.dev/reference/methods/chat.postMessage/
https://qiita.com/MakiMatsu/items/d47f351139866025825c

**ãƒ¡ãƒªãƒƒãƒˆ**
- ãƒãƒ£ãƒ³ãƒãƒ«ã‚’æŸ”è»Ÿã«æŒ‡å®šã§ãã‚‹ï¼ˆå›ºå®šã•ã‚Œãªã„ï¼‰
- ä»–ã® Slack API ã‚‚åˆ©ç”¨å¯èƒ½ï¼ˆã‚¹ãƒ¬ãƒƒãƒ‰è¿”ä¿¡ã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã€ãƒªãƒƒãƒãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãªã©ï¼‰
- æ¨©é™ç®¡ç†ãŒå³å¯†ï¼ˆå¿…è¦ãª Scope ã®ã¿ä»˜ä¸ï¼‰

**ãƒ‡ãƒ¡ãƒªãƒƒãƒˆ**
- åˆæœŸè¨­å®šãŒå°‘ã—æ‰‹é–“ï¼ˆApp ä½œæˆã€æ¨©é™ä»˜ä¸ã€ãƒˆãƒ¼ã‚¯ãƒ³ç®¡ç†ãŒå¿…è¦ï¼‰
- Bot ã‚’å¯¾è±¡ãƒãƒ£ãƒ³ãƒãƒ«ã«æ‹›å¾…ã—ãªã„ã¨æŠ•ç¨¿ã§ããªã„

# å®Ÿè£…æ–¹æ³•
ã‚¢ãƒ—ãƒªç®¡ç†ç”»é¢ã«ã„ãã¾ã™ã€‚
https://api.slack.com/apps
`OAuth & Permissions`ã®`Scopes`ã§ã€`chat:write`ã¨`chat:write.public`ã‚’è¨±å¯ã—ã¦ãŠãã¾ã™ã€‚
**chat:write**ï¼ˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ã«å¿…é ˆï¼‰
**chat:write.public**ï¼ˆä»»æ„ï¼šBot ãŒæœªå‚åŠ ãƒãƒ£ãƒ³ãƒãƒ«ã«ã‚‚æŠ•ç¨¿ã§ãã‚‹ï¼‰
![](/images/b1d6e7c36797c9/image-1.png)

ã‚¢ãƒ—ãƒªã‚’å†ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¾ã™ã€‚
`Bot User OAuth Token`ã¯ä½¿ç”¨ã—ã¾ã™ã®ã§æ§ãˆã¦ãŠã„ã¦ãã ã•ã„ã€‚
![](/images/b1d6e7c36797c9/image-2.png)

ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãŒã§ããŸã‚‰ã€ãƒ†ã‚¹ãƒˆã¨ã—ã¦ä»¥ä¸‹ã‚’ãƒªã‚¯ã‚¨ã‚¹ãƒˆã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚
```
curl -X POST https://slack.com/api/chat.postMessage \
  -H "Authorization: Bearer Bot User OAuth Token" \
  -H "Content-type: application/json" \
  --data '{
    "channel": "#æŒ‡å®šã—ãŸãƒãƒ£ãƒ³ãƒãƒ«å",
    "text": "Hello from Slack Bot :tada:"
  }'
```

æŒ‡å®šã—ãŸãƒãƒ£ãƒ³ãƒãƒ«ã«é€šçŸ¥ãŒæ¥ã‚Œã°æˆåŠŸã§ã™ï¼

### Lambda
`SLACK_BOT_TOKEN`ã¨`SLACK_CHANNEL` ã®ç’°å¢ƒå¤‰æ•°ã«å…ˆã»ã©ã®ãƒˆãƒ¼ã‚¯ãƒ³ã¨ãƒãƒ£ãƒ³ãƒãƒ«åï¼ˆ# ä»˜ãï¼‰ã¯é©å®œå¤‰æ›´ã—ã¦ãã ã•ã„ã€‚

```py
import os
import asyncio
import aiohttp
import feedparser
from datetime import datetime, timezone
import requests
import boto3
from botocore.exceptions import BotoCoreError, ClientError

# ç’°å¢ƒå¤‰æ•°
LINE_API_URL = "https://api.line.me/v2/bot/message/push"
LINE_TOKEN = os.environ["LINE_TOKEN"]
LINE_USER_ID = os.environ["LINE_USER_ID"]
SLACK_BOT_TOKEN = os.environ.get("SLACK_BOT_TOKEN")
SLACK_CHANNEL = os.environ.get("SLACK_CHANNEL")

# Amazon Translateã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
translate = boto3.client("translate", region_name="ap-northeast-1")

# é€ã£ãŸæ—¥ã¥ã‘
today_str = datetime.now(timezone.utc).strftime("%Y-%m-%d")

# RSSãƒ•ã‚£ãƒ¼ãƒ‰ä¸€è¦§
RSS_FEEDS = {
    "What's New with AWS": {"url": "https://aws.amazon.com/jp/about-aws/whats-new/recent/feed/", "translate": False},
    "AWS Blog": {"url": "https://aws.amazon.com/blogs/aws/feed/", "translate": True},
    "AWS Architecture Blog": {"url": "https://aws.amazon.com/jp/blogs/architecture/feed/", "translate": True},
    "AWS Partner Network (APN) Blog": {"url": "https://aws.amazon.com/jp/blogs/apn/feed/", "translate": True},
    "AWS Big Data Blog": {"url": "https://aws.amazon.com/jp/blogs/big-data/feed/", "translate": True},
    "AWS Compute Blog": {"url": "https://aws.amazon.com/jp/blogs/compute/feed/", "translate": True},
    "AWS Database Blog": {"url": "https://aws.amazon.com/jp/blogs/database/feed/", "translate": True},
    "AWS Desktop and Application Streaming Blog": {"url": "https://aws.amazon.com/jp/blogs/desktop-and-application-streaming/feed/", "translate": True},
    "AWS Developer Blog": {"url": "https://aws.amazon.com/jp/blogs/developer/feed/", "translate": True},
    "AWS DevOps Blog": {"url": "https://aws.amazon.com/jp/blogs/devops/feed/", "translate": True},
    "AWS Cloud Enterprise Strategy Blog": {"url": "https://aws.amazon.com/jp/blogs/enterprise-strategy/feed/", "translate": True},
    "Amazon Game Tech Blog": {"url": "https://aws.amazon.com/jp/blogs/gametech/feed/", "translate": True},
    "The Internet of Things on AWS â€“ Official Blog": {"url": "https://aws.amazon.com/jp/blogs/iot/feed/", "translate": True},
    "AWS Machine Learning Blog": {"url": "https://aws.amazon.com/jp/blogs/machine-learning/feed/", "translate": True},
    "AWS Management Tools Blog": {"url": "https://aws.amazon.com/jp/blogs/mt/feed/", "translate": True},
    "AWS Media Blog": {"url": "https://aws.amazon.com/jp/blogs/media/feed/", "translate": True},
    "AWS Messaging & Targeting Blog": {"url": "https://aws.amazon.com/jp/blogs/messaging-and-targeting/feed/", "translate": True},
    "AWS Mobile Blog": {"url": "https://aws.amazon.com/jp/blogs/mobile/feed/", "translate": True},
    "Networking & Content Delivery": {"url": "https://aws.amazon.com/jp/blogs/networking-and-content-delivery/feed/", "translate": True},
    "AWS Open Source Blog": {"url": "https://aws.amazon.com/jp/blogs/opensource/feed/", "translate": True},
    "AWS Government, Education, & Nonprofits Blog": {"url": "https://aws.amazon.com/jp/blogs/publicsector/feed/", "translate": True},
    "AWS for SAP": {"url": "https://aws.amazon.com/jp/blogs/awsforsap/feed/", "translate": True},
    "AWS Security Blog": {"url": "https://aws.amazon.com/jp/blogs/security/feed/", "translate": True},
    "AWS Startups Blog": {"url": "https://aws.amazon.com/jp/blogs/startups/feed/", "translate": True},
    "AWS Japan Blog": {"url": "https://aws.amazon.com/jp/blogs/news/feed/", "translate": False},
    "AWS Marketplace": {"url": "https://aws.amazon.com/blogs/awsmarketplace/feed/", "translate": True},
    "AWS Fundamentals Blog": {"url": "https://aws.amazon.com/blogs/training-and-certification/feed/", "translate": True},
    "AWS IoT Blog": {"url": "https://aws.amazon.com/blogs/iot/feed/", "translate": True},
    "é€±åˆŠAWS": {"url": "https://aws.amazon.com/jp/blogs/news/tag/%E9%80%B1%E5%88%8Aaws/feed/", "translate": False},
}

import re

def translate_title_if_needed(title, should_translate):
    """
    ãƒ•ã‚£ãƒ¼ãƒ‰è¨­å®šã«åŸºã¥ã„ã¦ã‚¿ã‚¤ãƒˆãƒ«ã‚’ç¿»è¨³ã™ã‚‹
    """
    if not should_translate:
        print(f"ç¿»è¨³è¨­å®šOFFã€ã‚¹ã‚­ãƒƒãƒ—: {title}")
        return title
        
    try:
        print(f"ç¿»è¨³è¨­å®šONã€ç¿»è¨³å®Ÿè¡Œ: {title}")
        result = translate.translate_text(
            Text=title,
            SourceLanguageCode="en",
            TargetLanguageCode="ja"
        )
        translated_title = result.get("TranslatedText", title)
        print(f"ç¿»è¨³å®Œäº†: {title} -> {translated_title}")
        return translated_title
        
    except (BotoCoreError, ClientError) as e:
        print(f"Translate error: {e}")
        return title

async def fetch_feed(session, name, feed_config):
    url = feed_config["url"]
    should_translate = feed_config["translate"]
    
    async with session.get(url) as resp:
        text = await resp.text()
        feed = feedparser.parse(text)
        today = datetime.now(timezone.utc).date()
        entries = []

        for entry in feed.entries[:10]:
            pub_date = None
            if hasattr(entry, "published_parsed") and entry.published_parsed:
                pub_date = datetime(*entry.published_parsed[:6], tzinfo=timezone.utc).date()
            elif hasattr(entry, "updated_parsed") and entry.updated_parsed:
                pub_date = datetime(*entry.updated_parsed[:6], tzinfo=timezone.utc).date()
            
            if pub_date == today:
                # ãƒ•ã‚£ãƒ¼ãƒ‰è¨­å®šã«åŸºã¥ã„ã¦ç¿»è¨³
                title = translate_title_if_needed(entry.title, should_translate)
                entries.append(f"ãƒ»{title}\n{entry.link}")
        return name, entries

async def fetch_all_feeds():
    async with aiohttp.ClientSession() as session:
        tasks = [fetch_feed(session, name, config) for name, config in RSS_FEEDS.items()]
        return await asyncio.gather(*tasks)

def send_line_message(message):
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {LINE_TOKEN}"
    }
    data = {
        "to": LINE_USER_ID,
        "messages": [{"type": "text", "text": message}]
    }
    resp = requests.post(LINE_API_URL, headers=headers, json=data)
    resp.raise_for_status()
    print("LINEé€ä¿¡æˆåŠŸ:", resp.status_code)

def send_slack_message(message):
    if not SLACK_BOT_TOKEN:
        print("Slack Bot Token ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€é€ä¿¡ã‚¹ã‚­ãƒƒãƒ—")
        return

    url = "https://slack.com/api/chat.postMessage"
    headers = {
        "Authorization": f"Bearer {SLACK_BOT_TOKEN}",
        "Content-Type": "application/json"
    }
    data = {
        "channel": SLACK_CHANNEL,
        "text": message
    }

    resp = requests.post(url, headers=headers, json=data)
    result = resp.json()
    if not result.get("ok"):
        print("Slacké€ä¿¡å¤±æ•—:", result)
        resp.raise_for_status()
    else:
        print("Slacké€ä¿¡æˆåŠŸ:", result)

def lambda_handler(event, context):
    feeds = asyncio.run(fetch_all_feeds())

    for name, entries in feeds:
        if entries:
            text = f"ã€{name}ã€‘ ({today_str})\n" + "\n".join(entries)
            send_line_message(text)
            send_slack_message(text)

    return {"statusCode": 200, "body": "é€šçŸ¥å®Œäº†"}

```